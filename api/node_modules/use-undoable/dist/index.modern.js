import { useReducer, useCallback } from 'react';

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

var payloadError = function payloadError(func) {
  throw new Error("NoPayloadError: " + func + " requires a payload.");
};

var invalidBehavior = function invalidBehavior(behavior) {
  throw new Error("Mutation behavior must be one of: mergePastReversed, mergePast, keepFuture, or destroyFuture. Not: " + behavior);
};

var ensureLimit = function ensureLimit(limit, arr) {
  if (!limit) return arr;
  var n = [].concat(arr);
  if (n.length <= limit) return arr;
  var exceedsBy = n.length - limit;

  if (exceedsBy === 1) {
    n.shift();
  } else {
    n.splice(0, exceedsBy);
  }

  return n;
};

var mutate = function mutate(state, action) {
  var past = state.past,
      present = state.present,
      future = state.future;
  var payload = action.payload,
      behavior = action.behavior,
      historyLimit = action.historyLimit,
      ignoreIdenticalMutations = action.ignoreIdenticalMutations,
      cloneState = action.cloneState,
      ignoreAction = action.ignoreAction;

  if (!payload) {
    payloadError('mutate');
  }

  if (ignoreAction) {
    return {
      past: past,
      present: payload,
      future: future
    };
  }

  var mPast = [].concat(past);

  if (historyLimit !== 'infinium' && historyLimit !== 'infinity') {
    mPast = ensureLimit(historyLimit, past);
  }

  var isEqual = JSON.stringify(payload) === JSON.stringify(present);

  if (ignoreIdenticalMutations && isEqual) {
    return cloneState ? _extends({}, state) : state;
  }

  var futureClone = [].concat(future);
  var behaviorMap = {
    mergePastReversed: {
      past: [].concat(mPast, futureClone.reverse(), [present]),
      present: payload,
      future: []
    },
    mergePast: {
      past: [].concat(mPast, future, [present]),
      present: payload,
      future: []
    },
    destroyFuture: {
      past: [].concat(mPast, [present]),
      present: payload,
      future: []
    },
    keepFuture: {
      past: [].concat(mPast, [present]),
      present: payload,
      future: future
    }
  };
  if (!behaviorMap.hasOwnProperty(behavior)) invalidBehavior(behavior);
  return behaviorMap[behavior];
};

var reducer = function reducer(state, action) {
  var past = state.past,
      present = state.present,
      future = state.future;

  var undo = function undo() {
    if (past.length === 0) {
      return state;
    }

    var previous = past[past.length - 1];
    var newPast = past.slice(0, past.length - 1);
    return {
      past: newPast,
      present: previous,
      future: [present].concat(future)
    };
  };

  var redo = function redo() {
    if (future.length === 0) {
      return state;
    }

    var next = future[0];
    var newFuture = future.slice(1);
    return {
      past: [].concat(past, [present]),
      present: next,
      future: newFuture
    };
  };

  var update = function update() {
    return mutate(state, action);
  };

  var reset = function reset() {
    var payload = action.payload;
    return {
      past: [],
      present: payload,
      future: []
    };
  };

  var resetInitialState = function resetInitialState() {
    var payload = action.payload;

    if (!payload) {
      payloadError('resetInitialState');
    }

    var mPast = [].concat(past);
    mPast[0] = payload;
    return {
      past: [].concat(mPast),
      present: present,
      future: [].concat(future)
    };
  };

  var actions = {
    undo: undo,
    redo: redo,
    update: update,
    reset: reset,
    resetInitialState: resetInitialState
  };
  return actions[action.type]();
};

var initialState = {
  past: [],
  present: null,
  future: []
};
var defaultOptions = {
  behavior: 'mergePastReversed',
  historyLimit: 100,
  ignoreIdenticalMutations: true,
  cloneState: false
};

var compileMutateOptions = function compileMutateOptions(options) {
  return _extends({}, defaultOptions, options);
};

var useUndoable = function useUndoable(initialPresent, options) {
  if (options === void 0) {
    options = defaultOptions;
  }

  var _useReducer = useReducer(reducer, _extends({}, initialState, {
    present: initialPresent
  })),
      state = _useReducer[0],
      dispatch = _useReducer[1];

  var canUndo = state.past.length !== 0;
  var canRedo = state.future.length !== 0;
  var undo = useCallback(function () {
    if (canUndo) {
      dispatch({
        type: 'undo'
      });
    }
  }, [canUndo]);
  var redo = useCallback(function () {
    if (canRedo) {
      dispatch({
        type: 'redo'
      });
    }
  }, [canRedo]);
  var reset = useCallback(function (payload) {
    if (payload === void 0) {
      payload = initialPresent;
    }

    return dispatch({
      type: 'reset',
      payload: payload
    });
  }, []);
  var resetInitialState = useCallback(function (payload) {
    return dispatch({
      type: 'resetInitialState',
      payload: payload
    });
  }, []);
  var update = useCallback(function (payload, mutationBehavior, ignoreAction) {
    return dispatch(_extends({
      type: 'update',
      payload: payload,
      behavior: mutationBehavior,
      ignoreAction: ignoreAction
    }, compileMutateOptions(options)));
  }, []);
  var setState = useCallback(function (payload, mutationBehavior, ignoreAction) {
    if (mutationBehavior === void 0) {
      mutationBehavior = options.behavior;
    }

    if (ignoreAction === void 0) {
      ignoreAction = false;
    }

    return typeof payload === 'function' ? update(payload(state.present), mutationBehavior, ignoreAction) : update(payload, mutationBehavior, ignoreAction);
  }, [state]);
  var static_setState = useCallback(function (payload, mutationBehavior, ignoreAction) {
    if (mutationBehavior === void 0) {
      mutationBehavior = options.behavior;
    }

    if (ignoreAction === void 0) {
      ignoreAction = false;
    }

    update(payload, mutationBehavior, ignoreAction);
  }, []);
  return [state.present, setState, {
    past: state.past,
    future: state.future,
    undo: undo,
    canUndo: canUndo,
    redo: redo,
    canRedo: canRedo,
    reset: reset,
    resetInitialState: resetInitialState,
    static_setState: static_setState
  }];
};

export default useUndoable;
//# sourceMappingURL=index.modern.js.map
